# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Ваньков Д.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |     15.12.2018         |     5 (отл)          |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта я получил следующие навыки и знания:

1. Углубил свои познания в теоретической части логического программирования. В процессе написания эссе на тему: "Как использовать логические языки чтобы научить компьютер играть в шахматы/шашки", я узнальше больше о языке логического программирования, искусственном интеллекте, а также о том, как со временем развивалось машинное обучение для игры в шахматы. Смог достаточно подробно описать алгоритм программирования игры "шахматы" на языке "Prolog".

2. Смог составить и обрабтать данные в формате GEDCOM. Если в будущем мне понадобится обрабатывать генеалогические деревья, то мне не придется разбираться с их структурой хранения.

3. Познакомился с языком функционального программирования "F#", а также написал парсер, обрабатывающий файл в формате GEDCOM.

4. Закрепил навыки, полученные в лабораторной работе номер 3, связанные с поиском в пространстве состояний. Мне они пригодились для реализации поиска в ширину, который, в свою очередь, был использован для получения цепочки родства.

5. Закрепил навыки, полученные в лабораторной работе номер 4, связанные с грамматическим разбором предложения.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: с использованием предикатов parent(родитель, ребенок), sex(человек, m/f).
 3. Реализовать предикат проверки/поиска золовки (сестры мужа).
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Мое родословное дерево было создано при помощи сервиса MyHeritage.com, в нем было 28 человек. Затем я экспортировал это дерево, с помощью встроенных в сервис функций, и получил файл в формате GEDCOM. 

## Конвертация родословного дерева

Для конвертации родословного дерева из формата GEDCOM в набор утверждений, указанный в варианте задания, я использовал функциональный язык программировния "F#".

Прежде, я не сталкивался с данным языком программирования, поэтому пришлось его изучить перед написанием программы. "F#" - это императивный язык, основанный на платформе ".Net", являющийся одним из самых популярных функциональных языков программирования. Программа, написанная на этом языке, представляет из себя некий набор функций, при этом каждая функция получает данные на вход и вырабатывает результат на выход. Каждая функция, как и вся программа в целом, не содержит как таковых переменных, что позволяет избежать ненужных ошибок. В компилятор встроенны такие структуры как массивы, списки, кортежи, что существенно уменьшает объем кода.

Перед тем, как написать нашу программу - "парсер", я попробовал несколько простых примеров, для того чтобы понять как все устроенно.

Листинг программы со всеми комментариями представлен [здесь](https://github.com/MAILabs-Education-LP/lp-capstone-DenVankov/blob/master/Parcer.fs).

## Предикат поиска родственника

Согласно варианту, мне нужно реализовать предикат по поиску "золовки" (сестра мужа).
Для этого необходимо реализовать промежуточные предикаты по поиску мужа и сестры.
В предикате husb() находится муж, если такой существует. Мы ищем общего ребенка с помощью предиката parent() и проверяем, что пол найденного родителя мужской. 
```Prolog
husb(Wife, Husband):- sex(Wife, f), parent(Wife, Child), parent(Husband, Child), sex(Husband, m).
```
В предикате sister() находится сестра, если она существует. Мы ищем второго ребенка от общего родителя, а также проверяем что он женского пола. 
```Prolog
sister(Sistr, X):-parent(Par, Sistr), parent(Par, X), sex(X, f), (Sistr\=X).
```
Сам предикат по поиску золовки выглядит следующим образом:
```Prolog
zolovka(Wife, Zol):-husb(Wife, Husband), sister(Husband, Zol).
```

Также мы можем реализовать все в 1 предикате, использую только базу знаний. Для этого последовательно выполняем действия:
 1. Находим отца и мать ребёнка.
 2. Находим родителя отца
 3. Ищем дочерей у родителя отца
```Prolog
sisterInLaw(Wife,SisterInLaw) :-
	sex(Wife, f),
	parent(Wife, Child),
	parent(Husband, Child),
	sex(Husband, m),
	parent(Grand, Husband),
	parent(Grand, SisterInLaw),
	sex(SisterInLaw, f).
```
Результат работы программы:
```Prolog
?- sisterInLaw("SechinaElena",X).
X = "VankovaMaria".
false.

?- zolovka("SechinaElena",X).
X = "VankovaMaria" ;
false.
```

## Определение степени родства

Для родственников первого поколения описываем предикаты родства, такие как: мама, папа, сын, дочь, брат, сестра, родитель, ребенок, муж, жена. Предикат connection() выступает в роли прямой, непосредственной, связи между 2 людьми.
Пример:
```Prolog
connection(father, Father, Child):-
    father(Father, Child).

connection(mother, Mother, Child):-
    mother(Mother, Child).

father(Dad, X):-parent(Dad, X), sex(Dad, m), !.
mother(Mom, X):-parent(Mom, X), sex(Mom, f), !.
```

Затем, используя поиск в ширину, опробованный в лабораторной работе номер 3, находим кратчайшее отношение родства. После этого мы находим "цепочку" родственников, по которой и связаны эти люди, а затем переводим ее в цепочку родства, получая ответ.

Результат работы предиката:
```Prolog
?- relative("VankovDenis", "VankovEgor",X).
X = [child, brother, father].

?- relative_thread("VankovDenis", "VankovEgor",X).
X = ["VankovDenis", "VankovAleksey", "VankovSergey", "VankovEgor"].
```

Это значит, что "VankovDenis" являеется ребенком брата отца "VankovEgor". И, ниже мы видим цепочку людей, через которых связаны 2 человека.

## Естественно-языковый интерфейс

На основе входных данных проверям верность высказывания, если оно корректно находится результат. В качестве входных данных мы принимаем список из слов на естественном языке. Также, с помощью предиката nb_getval() запоминается последнее имя, для возможности последующего обращения к нему, а также для построения с ним предложений. Используется далее это имя с помощью предиката nb_setval(). Предложение (список) анализируется аналогично лабораторной работе номер 4. Каждый элемент списка имеет свое назначение, к примеру, start_of_question() отвечает за начальное слово (how или who), или do_does за вспомогательные слова и т.д. 

Пример:
```Prolog
ask_the_question(List):-
      List = [Word, Quant, Relation, Does, Who, Have, Qstn],
      start_of_question(Word),
      quantity(Quant),
      multiples(Relation),
      do_does(Does),
      (sex(Who, m);
      sex(Who, f)),
      nb_setval(lastName, Who),
      have_has(Have),
      mark_of_question(Qstn),

      multiple(Rel1, Relation),
      setof(X, ask_relative(X, Who, Rel1),T),
      length(T, Res),!,
      write(Who),
      write(" has "),
      ((Res =:= 1, write(Res), write(" "), write(Rel1));
      (\+(Res =:= 1), write(Res), write(" "), write(Relation))),!.
```

Главный предикат ask_the_question() принимает на вход вопросительное предложение в виде списка и, если оно корректно, выводит результат. Корректность проверяется наличием всех слов, необходимых для того чтобы задать вопрос. Далее, введенное нами имя, запоминается и к нему можно будет обратиться в дальнейших вопросах с помощью местоимения, пока оно не будет перезаписано вопросом требующим ввести новое.

Результат работы:
```Prolog
?- ask_the_question([who,is,"VankovAleksey","'s",son,?]).
VankovDenis is VankovAleksey's son
true.

?- ask_the_question([who,is,his,father,?]).
VankovAleksey is VankovDenis's father
true.

?- ask_the_question([who,is,his,mother,?]).
SechinaElena is VankovDenis's mother
true.

?- ask_the_question([how,many,sisters,does,"MedvedevStepan",has,?]).
MedvedevStepan has 1 sister
true.
```
## Выводы

Первоначально, когда я еще не был знаком с таким языком логического программирования как "Prolog", мне было сложно понять принцип его работы, т.к. все языки с которыми я сталкивался были компилируемыми, к примеру, Си, С++, С#, Python. Чтобы понять принцип работы и научиться работать с этим языком пришлось, помимо лекций и лабораторных работ, прочитать книжку "Программирование на языке пролог" Большаковой и Груздевой. После ее прочтения, и долгих попыток у меня получилось написать первую программу, что стоило мне больших усилий. Однако, со временем, я стал свободнее ориентироваться в этом языке и мне он даже понравилися. Отсутвуют как таковые переменные, мы описываем условия, что мы хотим и как мы хотим это получить, что позволяет применять этот язык к логическим задачам. 

На примере данной работы, мы можем увидеть, что для ее решения лучше всего использовать логический язык программирования. Задача получить родословное дерево и, задавая различные вопросы, обращаться к нему, намного полезнее, чем написания несвязанных друг с другом предикатов, не имеющих практического применения.

В процессе изучения я приобрел несомненно полезный опыт, который я ,скорее всего, смогу применить в своих будующих работах.
