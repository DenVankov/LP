# Реферат
## по курсу "Логическое программирование"

### студент: Ваньков Д. А.

## ТЕМА
Как использовать логические языки чтобы научить компьютер играть в шахматы/шашки.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Вступление

   Первым делом нужно разобраться, что такое логический язык программирования или, как его еще называют, язык логики. Это язык, специально создаваемый для своих целей, способный следовать за логической формой рассуждения и воспроизводить ее. Значение отдельных слов и выражений зависят не только от них самих, но и от их окружения. Большинство слов имеют не одно, а несколько значений. А иногда, наоборот, одни и те же объекты могут иметь несколько имен. Существуют слова, не обозначающие никаких объектов, поэтому необходим искусственный язык, строящийся по строго сформулированным правилам. Этот язык должен выявлять логические связи в определенной задаче, он не предназначен для простого человеческого общения. Я считаю, именно это и делает язык логического программирования очень удобным для решения задач на логику.
  
  Возникает вопрос, где же может использоваться язык логики? Ответ не заставит долго себя ждать - например, в логическом программировании, которое основывается на выводе информации, являющейся результатом изученных фактов. Можно сравнить это с процессом обучения ребенка. Все объекты вокруг него помечены как доступные, кроме четко обозначенных, которые трогать нельзя. Получив наши указания, ребенок начинает познавать мир и, сопоставляя данные, принимать определенные решения. В логическом программировании этот принцип представлен в более сложной форме, основываясь на автоматическом доказательстве теорем, а также на раздел дискретной математики, изучающая принципы логического вывода информации на основе заданных фактов и правил вывода. Самым известным языком логического программирования и, скорее всего, самым популярным является "Prolog".
  
## Язык логического программирования "Prolog"

  "Prolog" - язык логического программирования, основанный на математической логике дизъюнктов и языке предикатов, представляющий собой подмножество логики предикатов первого порядка, такие как: отрицание («не»), конъюнкция («и»), дизъюнкция («или») и импликация («если ..., то ...»), а также кванторы всеобщности и существования. Основой в "Prolog" являются факты, правила логического вывода и запросы, позволяющие описывать базы знаний, процедуры логического вывода и принятия решений. Факты описываются логическими предикатами с конкретными значениями. Правила в "Prolog" записываются в форме правил логического вывода с логическими заключениями и списком логических условий. "Prolog" воспринимает в качестве программы некоторое описание задачи или базы знаний и сам осуществляет поиск всевозможных решений задач, пользуясь механизмом поиска с возвратом и унификацией.
  
  При написании программы на Прологе программист должен сосредоточить свое внимание на описание логической модели фрагмента предметной области решаемой задачи в терминах объектов этой области, их свойств и отношений между собой, а не саму программную реализацию. Программа на Прологе, в отличие от программы, написанной на интерпретируемых языках, не содержит явных условных операторов или операторов циклов и т.п. Она представлена в виде модели фрагмента предметной области, и решение задачи описывается в терминах конкретно этой предметной области решаемой задачи. Вкратце можно сказать, что суть Пролога – программирование в терминах целей. Программист описывает условие задачи, пользуясь понятиями об объектах различных типов и отношений между ними, и формулирует вопрос. В настоящее время создано достаточно много реализаций языка Пролог: SWI Prolog, Turbo Prolog, Visual Prolog, и т.д.
  
  Следующий вопрос, который может возникнуть - где же используется Пролог в настоящее время? Например, в области доказательства теорем, построение экспертных систем, перевод текстов с одного языка на другой или игры с эвристиками (например, шахматы или шашки), о которых я бы и хотел рассказать подробнее. 

## Как с помощью языка логики научить компьютер играть в шахматы
  
  Переходя к теме машинного обучения нужно выяснить, что оно из себя представляет. Машинное обучение - это совокупность методов и классов искусственного интеллекта, направленных не на прямое решение задачи, а постепенного обучения в процессе решения множества однотипных задач. В основном, для построения этих методов используются средства математической статистики, численных методов, теории вероятностей, графов и т.д. Выделяют два типа обучения: 1. Индуктивное обучение, основанное на выявлении закономерностей в данных.
2. Дедуктивное обучение, предполагающее формализацию знаний экспертов и их перенос в компьютер в качестве базы знаний.
  Впервые машина, созданная венгерским инженером Вольфгангом фон Компеленом, заиграла в шахматы в 1769 году. Такая машина была создана для развлечения королевы Марии-Терезии. Искусственный интеллект, действительно, неплохо играл, так как ходы были взяты с сильного шахматиста, который сам и говорил как нужно сходить в определенных ситуациях. Получается машина будет играть настолько умно, насколько ее научит человек.
  
   Конечно, первое что приходит в голову - это прописывание допустимых ходов и выбор случайного из возможных. Теоретически, компьютер будет ходить вполне корректно, однако насколько его шаги будут продуманными? Ответ прост - нисколько! Казалось бы, шахматы - это много вариативная игра, имеющая миллионы комбинаций и выборов действий, и чтобы компьютер мог хорошо играть, ему потребуется прорабатывать все эти варианты ходов в поиске наилучшего. Чтобы свести количество вариантов к минимуму необходим сложный и продуманный алгоритм, который будет выбирать подходящий ход на любом этапе игры. И, в 1962 году трое ученых, занимающимися изучением искусственного интеллекта, Аллен Ньюэлл, Герберт Саймон и Клиффорд Шоу открывают алгоритм, получивший название "alpha-beta". Альфа-бета-отсечение - это алгоритм поиска, стремящийся сократить количество узлов, оцениваемых в дереве поиска. Предназначен для антагонистических игр и используется для машинной игры, таких как компьютерные шахматы, шашки и других. В основе этого алгоритма лежит идея, что оценивание ветви дерева поиска может быть досрочно прекращено без вычисления всех значений оценивающей функции, т.е. если было установлено, что, для определённой ветви значение оценивающей функции в любом случае хуже, чем вычисленное в предыдущем шаге для предыдущей ветви. По сути альфа-бета-отсечение является оптимизацией, так как результаты работы оптимизируемого алгоритма не изменяются. Из-за того, что данный алгоритм не исследует все варианты, он значительно лучше полного перебора. Суть алгоритма заключается в том, что на каждом этапе игры для белых и черных отслеживались их максимальные результаты и, если в некоторый точке черные уже получили результат, равный максимуму белых, достигнутый до этого, то дальше перебор не имеет смысла. Когда перебор вернется в точку, где был достигнут максимум белых, результат все равно будет отвергнут, так как у белых в этой точке уже есть не худший ход.
  
   С течением времени программы по игре в шахматы улучшались. Из развития шахматных хочется отметить появление эвристики пустого хода или "NullMove". Его идея состоит в том, что в большинстве случаев, если мы пропускаем ход, то есть передача очереди противнику и перебор на меньшую глубину на два или более полхода, то происходит потеря, а не приобретение. Нулевой ход позволяет очень просто и на сравнительно неплохом уровне организовать выборочный поиск. Особенно хорошо он подходит для схем, где осуществляется стратегический расчет, а затем на полной вычислительной мощности счет одного материала с обрезкой неправдоподобных ветвей нулевым ходом.
   
   Недействительное перемещение (нулевой ход) позволяет просто настроить поиск и достигать больших глубин счета, невозможных при полном переборе. В шашках, например, его использовать нельзя. В чем заключается суть этого перемещения? Замечено, что в практически любой позиции в шахматах пропуск хода хуже, чем возможность сделать ход. Если у игрока есть ход, он может получить результат, гарантировано не хуже, чем если бы его не было.
   
   Как же это работает? Каждый узел содержит две величины - "alpha" и "beta". "Alpha" - это максимум "нашего" игрока, достигнутый в результате подсчета, а "beta" - максимум игрока противника. Если в результате подсчета получается оценка большая либо равная "beta", то счет можно не продолжать так как он больше не имеет смысла. Нулевой ход также можно использовать в качестве определения угрозы, однако делается это очень редко. Если после нашего хода попробовать ход на уменьшенную глубину, и результат вычисления говорит о том, что при пропуске хода мы выигрываем материал, то узел можно расширить. Чтобы избежать большого количества расширений, в качестве функции нулевого хода можно использовать только фиксированный поиск с нулевым окном. Выполняется он вполне быстро: если данный поиск показал выигрыш, глубину счета данного узла можно не уменьшать. В этом случае нулевой ход работает как индикатор или детектор атаки. Сама атака же определяется только для ходившей фигуры, то есть может ли фигура немедленно выиграть (получить выгоду по ценности) в результате размена. Получается, что нулевой ход, таким образом, не отсекает ветви дерева, а наоборот - расширяет. Такие узлы обрабатываются довольно быстро, так как в действительности таких ходов немного.

   В 1986 году на мировом первенстве в Германии Дон Бил участвовал с программой, которая использовала технику недействительного перемещения в его статическом поиске. В течение турнира Франц Морш заинтересовался этой идеей и спустя несколько лет осуществил ее в своей программе "Fritz". Ускорение получалось очень значительное, а результат очень точным. А, примерно с середины 1990-х годов недействительное перемещение было взято за основу шахматных программах и стало использоваться практически во всех. Следующее усовершенствование было сделано Эрнстом Хайнцем в его программе "DarkThough" и называлось "Futility pruning" и "Razoring". Заключалось оно в выборочном отсечении определенных пограничных ветвей дерева перебора, без их предварительного исследования. Отсекаемая позиция должна была удовлетворять определенным условиям. К примеру, задачка о способе расстановки 8 ферзей на доске 8×8 так, чтобы они не били друг друга решается методом перебора с помощью рекурсии. Допустим, нам нужно определить, бьется ли поле с координатами (X, Y) фигурами противника. Как это сделать? Существует множество способов, но применительно к данному примеру мы рассмотрим всего один. Предположим, что у нас есть 4 массива со значениями в ячейках, соответствующих фигурам противника, которые бьют на дальнее расстояние. В реальной программе это может делаться пошагово. Сделали ход — увеличили соответствующие ячейки в массиве на единицу, убрали — уменьшили. Если в первом массиве у нас не 0 в ячейке с индексом X, возможно, в этой вертикали есть ладья или ферзь. Мы должны проверить два "луча" в обоих направлениях до первой фигуры. Или, если в третьем массиве в ячейке с индексом (X+Y) не 0, то, возможно, на восходящей диагонали нас бьет ферзь или слон противника. В этом случае нам тоже придется проверить два "луча" по каждому направлению. Приращение при построении линии известно сразу. Для пешек же нужно просто проверять две соседние клетки по диагонали, что не представляет особой сложности. Несколько сложнее будет с королем и конем, так как у короля больше вариантов куда он может переместиться, а конь ходит не по стандартным траекториям (буквой "Г").
   
## Шахматы на Прологе

   А что, если мы захотим написать подобную программу по игре в шахматы на Прологе? На самом деле, в этом нет ничего сложно, если разобраться. Для этого разобьем нашу задачу на несколько блоков. Первый - это блок предикатов описания передвижения фигур, то есть как, куда и в каком случае может сходить та или иная фигура, находясь в определённой клетке для обеих сторон (черные и белые). 
   
   Затем, блок предикатов описывающий некий "старт" игры, то есть определяются начальные позиции у каждой из фигур, другими словами происходит расстановка фигур на шахматной доске, а также предикат вывода текущей позиции у каждой из фигур (некое отображение положения на шахматной доске). 
   
   Блок условий хода. То есть возможность перемещения, основывающиеся на текущем положении фигур на доске. При изменении позиции фигуры мы запоминаем ее местоположение на доске, к примеру мы решили сходить пешкой вперед на 1 клетку: для этого у нас будет запущена проверка на то, пустая ли эта клетка, если да, то координата будет увеличена на 1, если же там стоит фигура, то запустится проверка на то, можем ли мы "съесть" эту фигуру (в случае пешки нет, так как она ест только по диагонали на 1 клетку и ход не будет сделан), если условие позволяет мы "съедаем" фигуру, убирая ее с шахматной доски и ставим нашу фигуру на место съеденной.
   
   Блок состоящий из описания предиката хорошего хода, являющийся по сути самым главным предикатом. Хорошим считается ход, после которого нашему королю не будет поставлен мат. Если мы не можем сделать ход так, чтобы нашему королю не был поставлен мат, то игра считается проигранной.
   
   Теперь 2 блока игры: пользователя и компьютера. Блок игры пользователя выглядит проще, так как производится гораздо меньше проверок. Запрашивается фигура, и куда мы бы хотели ее передвинуть. После проверки всех условий на возможность хода, проверяется условие хорошего хода (то есть не будет ли у нас мата при этом ходе). А также, если пользователь играет цветом, у которого короля могу съесть за один последующий ход то выводится сообщение о шахе. В конце мы описываем предикат передачи хода компьютеру. Блок игры компьютера несколько сложнее. Ищется такая фигура, которая может за один ход взять фигуру противника, то делается именно этот ход. Если такой фигуры нет, то ищется та, которая могла бы сходить на свободно защищенное поле (то есть ее было бы нельзя съесть на следующем ходу). Если же и такой фигуры не находится, то она выбирается случайным образом путем сдвига списка фигур компьютера для выбора первой из этого списка. Если бы этого не было наш компьютер ходил гораздо меньшим количеством фигур.

   Дополнительный блок, содержащий различные вспомогательные предикаты, а также предикат выбора стороны пользователем и начала игры.
   
   Как мы можем заметить, это описание простейшей игры в шахматы пользователя с компьютером. Почему простейшее, потому что наш компьютер играет немного глупо, так как он старается съесть первую попавшуюся фигуру. Из-за этого опытный игрок может с легкостью завести его в ловушку, отдавая менее "ценные" фигуры и забирая более "дорогие". Чтобы сделать игру интереснее, можно было бы добавить приоритет хода, а также выбор ценности фигур, чтобы перед тем как съесть фигуру компьютер проверял не будет ли на следующем ходу съедена фигура меньшая по ценности. Также при выборе случайным сдвигом фигуры для хода, выбирались для начала фигуры меньшие по ценности, и король был задействован только в случае опасности или невозможности ходить другими фигурами.

   В отличие от шахмат, шашки гораздо проще, так как все фигуры одинаковые и вариаций ходов меньше, следовательно, код менее объемный и обучение машины происходит быстрее и легче. Длительность игры в шашки намного меньше, чем у игры в шахматы опять же из-за количества ходов и выбора фигур. Играя в приложении "шашки", я заметил, что при отмене хода и постановления этой же фигуры на то же место, машина не обязательно будет ходить как в прошлый раз. Однако, если дело дошло до конца игры, и ты проиграл, то при многократной отмене хода машина в любом случае будет делать победный ход. Из этого можно сделать вывод, что если программа видит ходы одинакового приоритета, то может изменить своё решение.

## Вывод

   Подводя итог можно сказать, что мы узнали, что такое язык логики, для чего он нужен и где он применяется. Его роль и поведение в логическом программировании, на примере языка "Prolog". Также познакомились с машинным обучением и искусственным интеллектом, и как происходило его развитие на примере игры в шахматы. Описали алгоритм написания примитивной игры пользователя с компьютером в шахматы на языке "Prolog", и выяснили какие есть недочеты у этого алгоритма и как можно было бы его улучшить.

 ## Список литературы

1. Интернет источник - википедия
2. Словарь терминов логики
3. Корнилов Е.Н. "Программирование шахмат и других логических игр."
4. Петер Флах - "Машинное обучение. Наука и искусство построения алгоритмов, которые извлекают знания из данных."
5. Иван Братко - "Алгоритмы искусственного интеллекта на языке PROLOG."
