#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Ваньков Д.А.


## Введение
Существует несколько типов логических задач на Прологе.
В задачах на установление соответствия мы прибываем в роли Шерлока Холмса, основываясь на фактах, которые нужно связать между собой чтобы найти решение.В ней мы описываем все имеющиеся факты и Пролог подставляет все возможные комбинации переменнных, соблюдая правила (факты) которые мы описали.
Задачи поиска в пространстве состояний. В них, если множество возможных состояний программы очень мало — то их можно задать на Прологе в виде графа, где вершины - это состояния, а дуги отражают возможность перехода между ними. Для решения задачи достаточно запустить поиск пути из начального состояния в конечное. Если требуется найти оптимальный путь, то к графу применяют алгоритм обхода в ширину, если же требуется найти все варианты решения — то обходят в глубину.

## Задание
3. Как-то раз случай свел в купе известного астронома, поэта, прозаика и драматурга. Это были Алексеев, Борисов, Константинов и Дмитриев. Оказалось, что каждый из них взял с собой книгу, написанную одним из пассажиров этого купе. Алексеев и Борисов углубились в чтение, предварительно обменявшись купленными книгами. Поэт читал пьесу. Прозаик, очень молодой человек, выпустивший свою первую книгу, говорил, что он никогда ничего не читает по астрономии. Борисов купил в дорогу одно из произведений Дмитриева. Никто из пассажиров не покупал и не читал книги, написанные им самим. Что читал каждый из них? Кто кем был?

## Принцип решения

На вход Пролог Программа принимает фамилии пассажиров и, путем подставления и комбинирования всех остальных переменных, а также опираясь на факты - условия описанные предикатами выводит все варианты (2), которые удовлетворяют всем правилам.

Первоначально нужно описать всех пассажиров купе.
```
man(alekseev).
man(borisov).
man(konstantinov).
man(dmitriev).
```
Затем аналогичным способом описать все варианты книг и, одновременно, профессий этих пассажиров.
```
book(astronomy).
book(poetry).
book(prose).
book(piece).
```
Основной и главный предикат, который принимает входной запрос в виде списка, затем производит преобразования и проверки с этим списком и выводит ответ.
```
solve(Solve):-
  Solve = [passenger(X, XRead, XBuy, XWrite), passenger(Y, YRead, YBuy, YWrite),
          passenger(Z, ZRead, ZBuy, ZWrite), passenger(W, WRead, WBuy, WWrite)],
```
Затем в нем производится проверка на уникальность каждого человека и то, что каждый из них купил и прочитал 1 из книг.
Пример проверки:
```
man(X), man(Y), man(Z), man(W), no_repetitions([X, Y, Z, W]),
```
Предикат проверки на уникальность прописан отдельно, в нем проверяется единственность вхождения элемента в список.
```
no_repetitions([]):-!.
no_repetitions([Head|Tail]):-
   member(Head, Tail), !, fail;
   no_repetitions(Tail).
```
Далее в предикате check() производится проверка на то, что человек не купил книгу, которую сам написал и не читал книгу, которую сам купил.
```
check([]):-!.
check([passenger(_, XRead, XBuy, XWrite)|T]):-
  check(T),!,not(XRead = XWrite), not(XBuy = XWrite).
```
Ниже производится проверка всех условий, указанных в задании, а именно:
```
  % Поэт читает пьесу
  member(passenger(_, piece, _, poetry), Solve),

  % Прозаик читает не астрономию
  not(member(passenger(_, astronomy, _, prose), Solve)),

  % прозаик не покупал астрономию
  not(member(passenger(_, _, astronomy, prose), Solve)),

  % Алексеев и Борисов обменялись книгами
  member(passenger(alekseev, AlekseevRead, AlekseevBuy, _), Solve),
  member(passenger(borisov, AlekseevBuy, AlekseevRead, _), Solve),

  % Борисов купил произведение Дмитриева
  member(passenger(dmitriev, _, _, DmitrievWrite), Solve),
  member(passenger(borisov, DmitrievWrite, _, _), Solve).
```

## Выводы

Пролог позволяет решать логические задачи иным способом, не таким как мы привыкли. Мы либо описываем все факты, проверки и состояния, которые указаны в условии задачи, а Пролог уже подставляет все возможные значения описанные нами. Пролог постепенно подставляя переменные проверяет выполняются ли все поставленные условия и выводит все варианты ответа, удовлетворяющие этим уловиям.
Либо мы описываем некоторые состояния или вершины, получая ориентированный граф, в котором поиск ответа это переход из какой-то начальной вершины (состояния) в конечную, которая в свою очередь и является ответом на поставленную задачу. Для решения подобного типа задач часто пользуются алгоритмами обхода графов в ширину или в глубину.
