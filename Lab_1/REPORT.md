# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Ваньков Д.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |       5       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Любой список в Прологе можно представить как стэк, в голове которого находится элемент, а в хвосте оставшаяся часть стэка. Элементами списка могут быть любые объекты. Список может быть либо пустым, либо состоять из 2х частей: головы и хвоста, который сам по себе тоже является списком.

Список в императивных языках сильно отличается от списка в Прологе.
То, что называется списком в императивных языках, сильно отличается от списка в Прологе. Обработка списка в Прологе может юыть осуществлена только рекурсивно, постепенно разделяя список на голову и хвост. В отличие от списков на Прологе, чтобы обратиться к какому-то элементу списка, мы можем использовать итераторы, с помощью которых мы получаем определенный элемент. Список в  Прологе, в отличие от списка в императивном языке, может содержать в себе элементы любого типа.

## Задание 1.1: Предикат обработки списка

Предикат:
```delThree(List,X).``` - Удаляет первые 3 элемента в списке. 

Примеры использования:
```prolog
?- delThree([1,2,3,4],X).
X = [4].

?- delThree([1,2],X).                                                       
X = [].
```

Реализация:
```
delThree([_,_,_|T], T) :- !.
delThree(_, []).
```
Предикат один раз удаляет первые три элемента в любом списке и выводит оставшийся список. Если список пустой, или имеет меньше 3 элементов, то предикат выводит пустой список.

Реализация на основе стандартных предикатов?

## Задание 1.2: Предикат обработки числового списка

Предикат:
```count(List,N).``` - Подсчитывает число вхождений первого элемента в список. 

Примеры использования:
```prolog
?- count([1,2,3,4,1],X).
X = 2.

?- count([],X).
X = 0.

?- count([1],X).
X = 1.
```

Реализация:
```
count([X|T],N):-count(X,T,N),!.
count(_,[],1).
count(X,[Y|T],N):-equal(X,Y),count(X,T,N1),N is N1 + 1.
count(X,[Y|T],N):-count(X,T,N).
count([],0).
```
Предикат выполняется рекурсивно. В начале отсекает голову и начинает работу с оставшейся частью списка. Если отсеченный в первом действии элемент является эквивалентным элементу из хвоста, то предикат запускает себя же и увеличивает счетчик на 1, в противном случае запускает себя только с оставшейся частью списка (хвостом), без изменений счетчика.
Если на вход подается пустой список, то число вхождений равно 0.

## Задание 2: Реляционное представление данных

Достоинства реляционной модели:
Простота и доступность для понимания пользователем. Единственной используемой информационной конструкцией является "таблица"; полная независимость данных. Изменения в прикладной программе при изменении реляционного представления минимальны; при организации запросов и написания прикладного ПО нет необходимости знать конкретную организацию представления во внешней памяти.

Недостатки реляционной модели: 
Далеко не всегда предметная область может быть представлена в виде "таблиц". В результате логического проектирования появляется множество "таблиц". Это приводит к трудности понимания структуры данных; представление занимает относительно много внешней памяти; относительно низкая скорость доступа к данным.

Реляционное представлние four.pl. 

Достоинства: Средняя занятость внешеней памяти невысокая. 

Недостатки: Строковая занятость хоть и не велика, однако размер строк очень большой. Для получения полного списка данных приходиться использовать конструкторы списков.

Предикат:
```find_center(Subject,Grade).``` - Подсчитывает средний балл для каждого предмета. 

Примеры использования:
```prolog
?- find_center(X,Y).
X = 'Логическое программирование',
Y = 4.107142857142857 ;
X = 'Математический анализ',
Y = 4.035714285714286 ;
X = 'Функциональное программирование',
Y = 4.107142857142857 ;
X = 'Информатика',
Y = 3.8214285714285716 ;
X = 'Английский язык',
Y = 4 ;
X = 'Психология',
Y = 3.857142857142857.
```

Реализация:
```
find_center(Subject,Grade) :- subject(Subject,L), add(L), count(Grade), delete(L).
```
Предикат add() рекурсивно созадет и добавляет в локальную базу элементы в формате grade('имя', оценка) для каждого предмета с помощью предиката asserz().

Предикат count() рекурсивно подсчитывет сумму всех оценок данного предмета, и затем получает среднее арифметическое деля эту сумму на длину списка всех оценок (предикат length()).

Предикат delete() рекурсивно удаляет локальную базу для каждого предмета с помощью предиката retract().

Предикат:
```count_group_fail().``` - Подсчитывает число студентов несдавших экзамены в каждой группе. 

Примеры использования:
```prolog
?- count_group_fail().
В группе 101 не сдало: 3
В группе 102 не сдало: 3
В группе 103 не сдало: 2
В группе 104 не сдало: 2
true.
```

Реализация:
```
count_group_fail() :-
  setof(Y,X^group(Y,X),Group_list),
  group_fail(Group_list).
  
group_fail([]) :- !.
group_fail([Group|T]) :-
  people_failed_exam(Group,Count),
  write('В группе '),
  write(Group),
  write(' не сдало: '),
  write(Count),
  nl,
  group_fail(T).
  
people_failed_exam(Group,Count) :-
  group(Group,Name_List),
  findall(List_of_list,subject(_,List_of_list),Grade_list),
  add_grade(Grade_list),
  count_losers(Name_List, Count),!
  delete(Grade_list).
```

Предикат group_fail() принимает список групп, запускает предикат people_failed_exam() для каждой группы, а также выводит ответ.

Предикат people_failed_exam() получает список всех оценок группы с помощью findall(), создает локальную базу оценок группы с помощью предиката add_grade() и вызывает предикат подсчета несдавших студентов count_losers(), а в самом конце удаляяет локальную базу с помощь delete().

Предикат count_losers() рекурсивно проходит список всех оценок группы и в случае, если оценка студента равняется 2, запускает сам себя же от хвоста и увеличивает счетчик несдавших на 1, если она не равна 2, то просто  запускает сам себя же без головы списка (от хвоста).

Предикат:
```count_subject_fail().``` - Подсчитывает число студентов несдавших экзамены по каждому предмету. 

Примеры использования:
```prolog
?- count_subject_fail().
Предмет Английский язык не сдало: 2
Предмет Информатика не сдало: 2
Предмет Логическое программирование не сдало: 3
Предмет Математический анализ не сдало: 1
Предмет Психология не сдало: 2
Предмет Функциональное программирование не сдало: 0
true.
```

Реализация:
```
count_subject_fail() :-
  setof(Y,X^subject(Y,X),Subject_list),
  subject_fail(Subject_list).
  
subject_fail([]) :- !.
subject_fail([Subject|Tail]) :-
  people_failed_subject(Subject,Count),
  write('Предмет '),
  write(Subject),
  write(' не сдало: '),
  write(Count),
  nl,
  subject_fail(Tail).
 
people_failed_subject(Subject,Count):-
  subject(Subject,Grade_List),
  add(Grade_List),
  findall(Mark,grade(Name,Mark),List_of_Marks),
  count_losers_sub(List_of_Marks,Count),!,
  delete(Grade_List).
```

Предикат subject_fail() принимает список предметов, запускает предикат people_failed_subject() для каждого предмета, а также выводит ответ.

Предикат people_failed_subject() создает локальную базу оценок предмета с помощью предиката add(), затем с помощью findall() получает список всех оценок по этому предмету и вызывает предикат подсчета несдавших студентов count_losers_sub(), и затем удаляет локальную базу оценок для предмета с помошью delete().

Предикат count_losers_sub() получает список всех оценок данного предмета, если оценка равна 2 запускает сам себя от хвоста и увеличивает счетчик на 1, в противном случае просто вызывает сам себя от хвоста без увелечения счетчика.

## Выводы

Данная лабораторная работа познакомила меня с совершенно не известным для меня языком Пролог. В нем, в отличие от имративных языков программирования, которые требуют указывать как что-то сделать, нужно указывать что нужно сделать. Мы используем предикаты, основываясь на том, что нам известно и задаем вопрос что нужно сделать. Поначалу, было очень сложно привыкнуть к этому языку, написание даже самых простейших предикатов вызывало сложность, однако по мере написания лабораторной постепенно осваиваешься и начинаешь понимать что тебе нужно. Если, лично у меня, в императивных языках возникала проблема при написании кода, то зачастую она была связана с поиском алгоритма, нежели его реализации, а в Прологе возникает проблема реализации данного алгоритма. Логическое программирование позволяет найти все решения определенной задачи, даже, порой, самые неочевидные. Набор предикатов помогает получить не только ответ на главный вопрос задачи, но и какие-то промежуточные ответы, тем самым давая понять, что решение задачи происходит с помощь раздеделения ее на множество подзадач. Данная работа позволила попробовать логическое программирование на простейших задачах, однако чтобы решать более сложные задачи правильно и быстро нужно больше практиковаться.
