#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Ваньков Д.А.

## Введение

Синтаксический разбор заключается в построение синтаксического дерева (оно же дерево выражения). Для построения такого дерева используется два подхода: восходящий и нисходящий. Нисходящий подход заключается в построении синтаксического дерева, начиная с начального нетерминального символа, из которого, следуя правилам грамматики, выводятся терминальные символы. Алгоритмы, использующие восходящий подход, строят дерево разбора начиная с листьев (терминальных вершин).

## Задание

Реализовать синтакический анализатор арифметического выражения и вычислить его числовое значение. В выражении допустимы операции '+', '-', '/', '\*', возведение в степень '^'. Учитывать приоритеты операций.

Пример:
```Prolog

| ?- calculate([5, +, 3, ^, 2], X).

X = 14.0

```

## Принцип решения

Программа получает список, состоящий из операторов и операндов. Представим его в виде: G = <VT,  NT, S0, P>, где VT-терминальный алфавит, NT-нетерминальный алфавит, S0-начальное сотояние, P-правило перехода между состояниями.
Сами списки представляют из себя: VT = {+, -, \*, /, 0, 1, ... , 9}, NT = {Expr, Term, Number}, где в Expr содержится '+', '-', в Term '/', '\*', '^', а в number соответсвенно 0, 1, ... , 9.

Для каждого из состояний мы должны описать правило перехода:

```
Expr -> Expr + Term
Expr -> Expr - Term
Expr -> Term

Term -> Pow
Term -> Term * Pow
Term -> Term / Pow

Pow -> Number
Pow -> Pow ^ Number

Number -> 0
-----------
Number -> 9
```
Здесь начальное состояние S0 = Expr.

Для удобства работы с выражением в Prolog, его необходимо реверсировать. Для разбиения списка на два, соответствующих правилам перехода, используется предикат append. Вот пример предиката, реализующего первое правило:

```Prolog
a_expr(Expr, Res):-
   append(Term, ['+'|Expr1], Expr),
   a_term(Term, Res1), a_expr(Expr1,Res2),
   Res is Res1 + Res2.
```

Список Еxpr разбивается на два: все что до первого "плюса" и после него. Если символа "плюс" в списке не будет, то предикат будет ложным и программа начнет подбирать другое правило.

Также, для того чтобы определить приоритет операции возведения в степень мы должны описать его следующим образом:
```Prolog
a_power(Term, Res):-
  append(Number,['^'|Term1], Term),
  a_number(Number, Res1), a_power(Term1, Res2),
  Res is Res2 ** Res1.
```
Сами числа получаются с помощью предиката a_number, и, аналогичного ему a_power:
```Prolog
a_number([Number],Number):- number(Number).
```

## Результаты

Результаты работы программы:

```Prolog

?- calculate([2,-,3],X).
X = -1.

?- calculate([2,^,3,+,1],Res).
Res = 9.

?- calculate([2,'*',2,'^',3,'/',4,'+',4,'*',5],X).
X = 24.

?- calculate([2,^,+,3,+,1],Res).
false.
```

## Выводы

Таким образом, в ходе лабораторной работы была успешно выполнена поставленная задача. Проанализировав получившуюся программу и ту, что была написана в прошлом году на языке Си, я пришел к выводу, что Prolog более хорошо подходит для задач, связанных с разбором синтаксичеких выражений, программа получилась гораздо меньше и более читабельна. Это обусловлено декларативной семантикой языка и тем, что составленные правила грамматики напрямую отображаются в предикаты Prolog'a (На самом деле, этот язык программирования изначально задумывался для упрощения написания задач подобного типа).

